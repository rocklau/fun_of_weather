<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <title>äº‘çš„æ—è°±ï¼šé£åœºä¸æ¼”åŒ–å¯è§†åŒ–</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0b1015;
            font-family: 'Segoe UI', sans-serif;
        }

        /* UI å±‚å¸ƒå±€ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 30px;
            box-sizing: border-box;
        }

        /* 1. é¡¶éƒ¨æŠ¬å¤´ */
        #header {
            text-align: center;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.8);
            position: relative;
            z-index: 2;
        }

        h1 {
            margin: 0;
            color: #fff;
            font-size: 36px;
            letter-spacing: 4px;
            font-weight: 300;
        }

        #sub-text {
            color: #4db8ff;
            font-size: 16px;
            margin-top: 5px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #desc-text {
            color: #ccc;
            font-size: 14px;
            margin-top: 15px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            line-height: 1.6;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* 2. å³ä¾§é£åŠ›ä»ªè¡¨ç›˜ */
        #wind-monitor {
            position: absolute;
            top: 50%;
            right: 30px;
            transform: translateY(-50%);
            width: 240px;
            background: rgba(15, 25, 40, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(77, 184, 255, 0.3);
            border-radius: 12px;
            padding: 20px;
            color: white;
            pointer-events: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .monitor-title {
            font-size: 12px;
            color: #88aadd;
            text-transform: uppercase;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 8px;
            margin-bottom: 15px;
        }

        .gauge-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .gauge-label {
            font-size: 13px;
            color: #ddd;
        }

        .gauge-val {
            font-weight: bold;
            font-size: 14px;
            color: #4db8ff;
        }

        /* ç®­å¤´å®¹å™¨ */
        .arrow-box {
            width: 40px;
            height: 40px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            background: rgba(0, 0, 0, 0.3);
        }

        .arrow {
            font-size: 20px;
            color: #fff;
            transition: transform 0.5s;
        }

        .wind-bar {
            height: 4px;
            background: #333;
            border-radius: 2px;
            width: 100%;
            margin-top: 5px;
            overflow: hidden;
        }

        .wind-fill {
            height: 100%;
            background: linear-gradient(90deg, #4db8ff, #ff4d4d);
            width: 0%;
            transition: width 1s ease-in-out;
        }

        /* 3. åº•éƒ¨è¿›åŒ–é€‰é¡¹ */
        #evolution-panel {
            pointer-events: auto;
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .evo-btn {
            background: rgba(30, 40, 60, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-left: 4px solid #4db8ff;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 220px;
            position: relative;
        }

        .evo-btn:hover {
            background: #4db8ff;
            color: #001f3f;
            transform: translateY(-5px);
        }

        .evo-btn .condition {
            font-size: 11px;
            opacity: 0.7;
            display: block;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .evo-btn .target {
            font-size: 16px;
            font-weight: bold;
        }

        /* 4. å·¦ä¾§é«˜åº¦è®¡ */
        #alt-monitor {
            position: absolute;
            top: 50%;
            left: 30px;
            transform: translateY(-50%);
            height: 300px;
            width: 60px;
            background: rgba(15, 25, 40, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(77, 184, 255, 0.3);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 0;
            pointer-events: auto;
        }

        .alt-scale {
            flex: 1;
            width: 2px;
            background: rgba(255, 255, 255, 0.2);
            position: relative;
            margin: 10px 0;
        }

        .alt-marker {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 8px;
            height: 1px;
            background: rgba(255, 255, 255, 0.5);
        }

        .alt-label {
            position: absolute;
            left: 15px;
            font-size: 10px;
            color: #888;
            transform: translateY(-50%);
        }

        #plane-indicator {
            position: absolute;
            left: -10px;
            width: 0;
            height: 0;
            border-left: 8px solid #ffaa00;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            transition: bottom 0.1s;
            /* Smoother update in JS */
        }

        #plane-alt-text {
            position: absolute;
            left: 15px;
            top: -15px;
            color: #ffaa00;
            font-weight: bold;
            font-size: 12px;
            width: 50px;
        }
    </style>
</head>

<body>

    <div id="ui-layer">
        <div id="header">
            <h1 id="cloud-name">Cloud Simulator</h1>
            <div id="sub-text">Initialization</div>
            <div id="desc-text">Loading atmospheric data...</div>
        </div>

        <div id="wind-monitor">
            <div class="monitor-title">ğŸ’¨ å¤§æ°”åŠ¨åŠ›å­¦ç›‘æµ‹</div>

            <!-- å‚ç›´é£ -->
            <div style="margin-bottom: 20px;">
                <div class="gauge-row">
                    <div style="display:flex; align-items:center;">
                        <div class="arrow-box">
                            <div class="arrow" id="arrow-v">â¬†</div>
                        </div>
                        <span class="gauge-label">å‚ç›´å¯¹æµ<br><span
                                style="font-size:10px; opacity:0.6;">(Updraft)</span></span>
                    </div>
                    <span class="gauge-val" id="val-v">0 m/s</span>
                </div>
                <div class="wind-bar">
                    <div class="wind-fill" id="bar-v"></div>
                </div>
            </div>

            <!-- æ°´å¹³é£ -->
            <div>
                <div class="gauge-row">
                    <div style="display:flex; align-items:center;">
                        <div class="arrow-box">
                            <div class="arrow" id="arrow-h">â¡</div>
                        </div>
                        <span class="gauge-label">æ°´å¹³é£åˆ‡å˜<br><span style="font-size:10px; opacity:0.6;">(Wind
                                Shear)</span></span>
                    </div>
                    <span class="gauge-val" id="val-h">0 m/s</span>
                </div>
                <div class="wind-bar">
                    <div class="wind-fill" id="bar-h"></div>
                </div>
            </div>

            <div
                style="margin-top: 15px; font-size: 12px; color: #aaa; border-top: 1px solid rgba(255,255,255,0.1); padding-top:10px;">
                ç¯å¢ƒçŠ¶æ€: <span id="env-status" style="color: #fff; font-weight: bold;">Stable</span>
            </div>
        </div>

        <div id="evolution-panel">
            <!-- Buttons generated by JS -->
        </div>

        <div id="alt-monitor">
            <div style="font-size:10px; color:#88aadd; margin-bottom:5px;">ALT</div>
            <div class="alt-scale">
                <div class="alt-marker" style="bottom:0%"><span class="alt-label">0km</span></div>
                <div class="alt-marker" style="bottom:25%"><span class="alt-label">3km</span></div>
                <div class="alt-marker" style="bottom:50%"><span class="alt-label">6km</span></div>
                <div class="alt-marker" style="bottom:75%"><span class="alt-label">9km</span></div>
                <div class="alt-marker" style="bottom:100%"><span class="alt-label">12km</span></div>

                <div id="plane-indicator" style="bottom: 10%;">
                    <div id="plane-alt-text">1.2km</div>
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "tween": "https://unpkg.com/@tweenjs/tween.js@23.1.1/dist/tween.esm.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import TWEEN from 'tween';

        // --- 1. æ•°æ®é…ç½®ï¼šæ¼”åŒ–è·¯å¾„ä¸é£åŠ›å‚æ•° ---
        const CLOUD_EVOLUTION = {
            'vapor': {
                name: "ğŸ’§ æ°´è’¸æ°” (Vapor)",
                sub: "æ— å½¢é˜¶æ®µ",
                desc: "åœ°é¢å—çƒ­ï¼Œä¸å¯è§çš„æ°´åˆ†å­å¼€å§‹æ´»è·ƒã€‚æ­¤æ—¶å‚ç›´çƒ­å¯¹æµåˆšåˆšå¼€å§‹ã€‚",
                wind: { v: 2, h: 1, turb: 0.1, curl: 0.1 },
                altitude: 5, // Near ground
                env: "åœ°é¢åŠ çƒ­ä¸­...",
                options: [
                    { target: 'cumulus_humilis', condition: "ğŸ”¥ çƒ­ç©ºæ°”ä¸Šå‡ + å‡ç»“", text: "å½¢æˆæ·¡ç§¯äº‘" }
                ]
            },
            'cumulus_humilis': {
                name: "â˜ï¸ æ·¡ç§¯äº‘ (Cumulus Humilis)",
                sub: "åˆç”ŸæœŸ",
                desc: "æ™´å¤©å°äº‘æœµã€‚ä¾é æ¸©å’Œçš„å‚ç›´ä¸Šå‡æ°”æµç»´æŒï¼Œå¦‚æœé£å¤ªå¤§å°±ä¼šè¢«å¹æ•£ã€‚",
                wind: { v: 5, h: 2, turb: 0.2, curl: 0.3 },
                altitude: 15, // Low
                env: "æ°”æµå¹³ç¨³ (Stable)",
                options: [
                    { target: 'vapor', condition: "ğŸ’¨ ç©ºæ°”å¹²ç‡¥/ä¸‹æ²‰", text: "è’¸å‘æ¶ˆæ•£" },
                    { target: 'cumulus_congestus', condition: "ğŸŒ¡ï¸ å¼ºçƒ­å¯¹æµ (Strong Updraft)", text: "çˆ†å‘å¢é•¿ï¼šæµ“ç§¯äº‘" },
                    { target: 'stratocumulus', condition: "ğŸŒ¬ï¸ é€†æ¸©å±‚é˜»æŒ¡/æ°´å¹³æ‰©æ•£", text: "å¹³é“ºï¼šå±‚ç§¯äº‘" }
                ]
            },
            'cumulus_congestus': {
                name: "ğŸ¥¦ æµ“ç§¯äº‘ (Cumulus Congestus)",
                sub: "æ´»è·ƒå‘å±•æœŸ",
                desc: "å¼ºçƒˆçš„ä¸Šå‡æ°”æµåƒæ³µä¸€æ ·æŠŠæ°´æ±½é€å…¥é«˜ç©ºã€‚äº‘ä½“å†…å¯¹æµæ—ºç››ã€‚",
                wind: { v: 15, h: 3, turb: 0.5, curl: 0.8 },
                altitude: 30, // Mid
                env: "å¤§æ°”ä¸ç¨³å®š (Unstable)",
                options: [
                    { target: 'cumulonimbus', condition: "âš¡ èƒ½é‡çˆ†å‘ + é«˜ç©ºå†°æ™¶åŒ–", text: "è¿›åŒ–ï¼šç§¯é›¨äº‘" },
                    { target: 'cumulus_humilis', condition: "ğŸ“‰ çƒ­åŠ›å‡å¼±", text: "é€€åŒ–ï¼šæ·¡ç§¯äº‘" }
                ]
            },
            'cumulonimbus': {
                name: "â›ˆï¸ ç§¯é›¨äº‘ (Cumulonimbus)",
                sub: "é£æš´æˆç†ŸæœŸ",
                desc: "æå¼ºä¸Šå‡æ°”æµå†²ç ´å¯¹æµå±‚ï¼é¡¶éƒ¨é‡é«˜ç©ºå¼ºé£å½¢æˆé“ç §ã€‚å†…éƒ¨æ°”æµæåº¦æ··ä¹±ã€‚",
                wind: { v: 25, h: 20, turb: 1.5, curl: 2.0 }, // High curl for vortices
                altitude: 45, // High vertical extent
                env: "âš¡ å‰§çƒˆé£æš´ (Storm)",
                options: [
                    { target: 'cirrus_spissatus', condition: "â˜” æš´é›¨è€—å°½èƒ½é‡", text: "æ®‹ä½™ï¼šä¼ªå·äº‘" }
                ]
            },
            'stratocumulus': {
                name: "ğŸŒŠ å±‚ç§¯äº‘ (Stratocumulus)",
                sub: "ç¨³å®šæœŸ",
                desc: "å‚ç›´æ°”æµå—é˜»ï¼Œäº‘ä½“åªèƒ½æ²¿æ°´å¹³æ–¹å‘é“ºå¼€ã€‚é€šå¸¸é£é€Ÿå¹³ç¼“ã€‚",
                wind: { v: 1, h: 8, turb: 0.1, curl: 0.2 },
                altitude: 12, // Low-Mid
                env: "å±‚ç»“ç¨³å®š",
                options: [
                    { target: 'stratus', condition: "ğŸŒ«ï¸ äº‘åº•é™ä½", text: "å˜æˆå±‚äº‘" },
                    { target: 'cumulus_humilis', condition: "â˜€ æ‰°åŠ¨åˆ†è§£", text: "æ–­è£‚ä¸ºç§¯äº‘" }
                ]
            },
            'stratus': {
                name: "ğŸŒ«ï¸ å±‚äº‘ (Stratus)",
                sub: "é™ç¨³æœŸ",
                desc: "é£åŠ›å¾®å¼±ï¼Œå‡ ä¹æ²¡æœ‰å‚ç›´è¿åŠ¨ã€‚åƒæ­»æ°´ä¸€æ ·çš„äº‘å±‚ã€‚",
                wind: { v: 0.5, h: 4, turb: 0.05, curl: 0.0 },
                altitude: 8, // Very Low
                env: "é™é£/å¾®é£",
                options: [
                    { target: 'stratocumulus', condition: "ğŸŒ¬ï¸ æ°”æµæ‰°åŠ¨", text: "æŠ¬å‡ä¸ºå±‚ç§¯äº‘" }
                ]
            },
            'cirrus_spissatus': {
                name: "ğŸª¶ å¯†å·äº‘ (Cirrus Spissatus)",
                sub: "é«˜ç©ºæ®‹ç•™",
                desc: "ä½äºæé«˜ç©ºï¼Œå®Œå…¨å—'é«˜ç©ºæ€¥æµ'æ§åˆ¶ã€‚é£é€Ÿæå¿«ï¼Œå°†äº‘æ‹‰æˆä¸ã€‚",
                wind: { v: 0, h: 30, turb: 0.2, curl: 0.5 },
                altitude: 70, // Very High
                env: "é«˜ç©ºæ€¥æµ (Jet Stream)",
                options: [
                    { target: 'vapor', condition: "ğŸ’¨ å¹æ•£", text: "å¾ªç¯ï¼šé‡ç½®" }
                ]
            }
        };

        // --- 2. åœºæ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x11151c);
        scene.fog = new THREE.FogExp2(0x11151c, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 90);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
        sunLight.position.set(50, 100, 50);
        scene.add(sunLight);

        // åœ°é¢ç½‘æ ¼
        const grid = new THREE.GridHelper(200, 40, 0x445566, 0x223344);
        grid.position.y = -20;
        scene.add(grid);

        // --- 3. é£åœºå¯è§†åŒ–ç³»ç»Ÿ (Wind Field System) ---
        // ä½¿ç”¨çº¿æ¡æ¨¡æ‹Ÿæ°”æµ
        const windLinesGroup = new THREE.Group();
        scene.add(windLinesGroup);

        const windParticles = [];
        const windCount = 200;

        // åˆ›å»ºé£çš„çº¿æ¡å‡ ä½•ä½“
        const windGeo = new THREE.BufferGeometry();
        // æ¯ä¸ªçº¿æ¡æ˜¯ä¸€ä¸ªç®€å•çš„ 2ç‚¹ çº¿æ®µï¼Œä½†åœ¨updateä¸­æˆ‘ä»¬ä¼šç§»åŠ¨å®ƒä»¬
        // ä¸ºäº†ç®€åŒ–ï¼Œè¿™é‡Œä½¿ç”¨ Trail é£æ ¼çš„ç²’å­ (é•¿æ¡ Sprite)

        function createWindTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 16;
            const ctx = canvas.getContext('2d');
            const g = ctx.createLinearGradient(0, 0, 64, 0);
            g.addColorStop(0, 'rgba(255,255,255,0)');
            g.addColorStop(0.5, 'rgba(255,255,255,0.5)');
            g.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, 64, 16);
            return new THREE.CanvasTexture(canvas);
        }
        const windMat = new THREE.SpriteMaterial({
            map: createWindTexture(),
            color: 0x88ccff,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending
        });

        for (let i = 0; i < windCount; i++) {
            const p = new THREE.Sprite(windMat.clone());
            p.position.set((Math.random() - 0.5) * 100, (Math.random() - 0.5) * 50 + 20, (Math.random() - 0.5) * 100);
            p.scale.set(5, 0.5, 1); // åˆå§‹ç»†é•¿
            p.userData = {
                id: i,
                speedMod: Math.random() * 0.5 + 0.5, // é€Ÿåº¦å·®å¼‚
                resetY: -20
            };
            windLinesGroup.add(p);
            windParticles.push(p);
        }

        // --- 4. äº‘ç²’å­ç³»ç»Ÿ ---
        function createCloudTexture() {
            const c = document.createElement('canvas');
            c.width = 64; c.height = 64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(c);
        }
        const cloudMat = new THREE.SpriteMaterial({ map: createCloudTexture(), color: 0xffffff, transparent: true, opacity: 0.8 });

        const cloudGroup = new THREE.Group();
        scene.add(cloudGroup);
        const cloudParticles = [];

        for (let i = 0; i < 300; i++) {
            const p = new THREE.Sprite(cloudMat.clone());
            p.position.y = -100; // Hide initially
            p.userData = { noise: Math.random() };
            cloudGroup.add(p);
            cloudParticles.push(p);
        }

        // --- 5. çŠ¶æ€ç®¡ç†ä¸åŠ¨ç”»é€»è¾‘ ---
        let currentEnv = { v: 0, h: 0, turb: 0, curl: 0, alt: 10 };
        let targetEnv = { v: 0, h: 0, turb: 0, curl: 0, alt: 10 };

        function morphTo(key) {
            const data = CLOUD_EVOLUTION[key];

            // 1. æ›´æ–°æ–‡æœ¬ UI
            document.getElementById('cloud-name').innerText = data.name;
            document.getElementById('sub-text').innerText = data.sub;
            document.getElementById('desc-text').innerText = data.desc;
            document.getElementById('env-status').innerText = data.env;

            updateButtons(data.options);

            // 2. æ›´æ–°ç¯å¢ƒç›®æ ‡å€¼
            targetEnv.v = data.wind.v;
            targetEnv.h = data.wind.h;
            targetEnv.turb = data.wind.turb;
            targetEnv.curl = data.wind.curl;
            targetEnv.alt = data.altitude;

            updateWindGaugeUI(targetEnv);

            // 3. èƒŒæ™¯ç¯å¢ƒè‰²è°ƒæ•´
            let bgHex = 0x11151c;
            if (key === 'vapor') bgHex = 0x87CEEB;
            if (key.includes('cumulus')) bgHex = 0x4db8ff;
            if (key === 'cumulonimbus') bgHex = 0x1a1a2e; // æš´é£é›¨æš—
            if (key === 'stratus') bgHex = 0x778899;

            new TWEEN.Tween(scene.background)
                .to(new THREE.Color(bgHex), 2000)
                .start();

            // 4. äº‘ç²’å­å˜å½¢ (Morphing Logic)
            cloudParticles.forEach((p, i) => {
                let tx = 0, ty = 0, tz = 0, s = 1, op = 1, vis = true;
                const r = p.userData.noise;

                switch (key) {
                    case 'vapor':
                        vis = i < 100;
                        tx = (r - 0.5) * 60; ty = -15 + r * 10; tz = (Math.random() - 0.5) * 60;
                        s = 2; op = 0.3; // åŠé€æ˜
                        p.material.color.setHex(0xaaddff);
                        break;
                    case 'cumulus_humilis':
                        vis = i < 120;
                        tx = (r - 0.5) * 30; ty = 0 + Math.sin(r * Math.PI) * 15; tz = (Math.random() - 0.5) * 30;
                        s = 8; op = 0.8;
                        p.material.color.setHex(0xffffff);
                        break;
                    case 'cumulus_congestus':
                        vis = i < 250;
                        tx = (r - 0.5) * 30; ty = 0 + Math.pow(r, 1.5) * 50; tz = (Math.random() - 0.5) * 30;
                        s = 10; op = 0.9;
                        p.material.color.setHex(0xffffff);
                        break;
                    case 'cumulonimbus':
                        vis = true;
                        let h = r * 70;
                        let w = 25;
                        if (h > 50) w = 25 + (h - 50) * 5; // é“ç §
                        tx = (Math.random() - 0.5) * w; ty = h - 5; tz = (Math.random() - 0.5) * w;
                        s = 15; op = 1;
                        // åº•éƒ¨é»‘
                        if (h < 20) p.material.color.setHex(0x444455);
                        else p.material.color.setHex(0xffffff);
                        break;
                    case 'stratocumulus':
                        vis = i < 200;
                        tx = (r - 0.5) * 100; ty = 10 + Math.sin(tx * 0.2) * 5; tz = (Math.random() - 0.5) * 80;
                        s = 10; op = 0.8;
                        p.material.color.setHex(0xeeeeee);
                        break;
                    case 'stratus':
                        vis = i < 250;
                        tx = (r - 0.5) * 120; ty = 5 + r * 5; tz = (Math.random() - 0.5) * 100;
                        s = 15; op = 0.5;
                        p.material.color.setHex(0xcccccc);
                        break;
                    case 'cirrus_spissatus':
                        vis = i < 150;
                        tx = (r - 0.5) * 80; ty = 60 + r * 10; tz = (Math.random() - 0.5) * 40;
                        s = 5; op = 0.6;
                        p.scale.set(15, 2, 1); // æ‹‰é•¿
                        break;
                }

                if (vis) {
                    p.visible = true;
                    new TWEEN.Tween(p.position).to({ x: tx, y: ty, z: tz }, 2000).easing(TWEEN.Easing.Quadratic.InOut).start();
                    new TWEEN.Tween(p.scale).to({ x: s, y: s }, 2000).start();
                    new TWEEN.Tween(p.material).to({ opacity: op }, 1000).start();
                } else {
                    new TWEEN.Tween(p.material).to({ opacity: 0 }, 1000).onComplete(() => { p.visible = false }).start();
                }
            });
        }

        function updateWindGaugeUI(wind) {
            // å‚ç›´é£æ¡ (Max 30)
            const vPct = Math.min((wind.v / 30) * 100, 100);
            document.getElementById('bar-v').style.width = vPct + '%';
            document.getElementById('val-v').innerText = wind.v + " m/s";

            // æ°´å¹³é£æ¡ (Max 40)
            const hPct = Math.min((wind.h / 40) * 100, 100);
            document.getElementById('bar-h').style.width = hPct + '%';
            document.getElementById('val-h').innerText = wind.h + " m/s";

            // ç®­å¤´æ—‹è½¬
            const arrowV = document.getElementById('arrow-v');
            if (wind.v > 5) arrowV.style.transform = "rotate(0deg)"; // Up
            else if (wind.v < 0) arrowV.style.transform = "rotate(180deg)"; // Down
            else arrowV.style.transform = "scale(0.8)"; // Weak

            const arrowH = document.getElementById('arrow-h');
            arrowH.style.transform = `rotate(-90deg) scale(${0.5 + wind.h / 20})`; // Right, scale by speed
        }

        function updateButtons(options) {
            const panel = document.getElementById('evolution-panel');
            panel.innerHTML = '';
            options.forEach(opt => {
                const btn = document.createElement('div');
                btn.className = 'evo-btn';
                btn.innerHTML = `<span class="condition">${opt.condition}</span><span class="target">${opt.text}</span>`;
                btn.onclick = () => morphTo(opt.target);
                panel.appendChild(btn);
            });
        }

        // --- 6. åŠ¨ç”»å¾ªç¯ ---
        morphTo('vapor');

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();

            // å¹³æ»‘æ’å€¼å½“å‰ç¯å¢ƒå‚æ•°
            currentEnv.v += (targetEnv.v - currentEnv.v) * 0.02;
            currentEnv.h += (targetEnv.h - currentEnv.h) * 0.02;
            currentEnv.turb += (targetEnv.turb - currentEnv.turb) * 0.02;
            currentEnv.curl += (targetEnv.curl - currentEnv.curl) * 0.02;
            currentEnv.alt += (targetEnv.alt - currentEnv.alt) * 0.01; // Altitude changes slower

            // æ›´æ–°é£åœºç²’å­ (Wind Lines Animation)
            windParticles.forEach(p => {
                const spd = p.userData.speedMod;

                // 1. åŸºç¡€é£åŠ›ä½ç§»
                p.position.y += currentEnv.v * 0.05 * spd;
                p.position.x += currentEnv.h * 0.05 * spd;

                // 2. å¢åŠ æµåŠ¨æ„Ÿï¼šæ­£å¼¦æ³¢æ‰°åŠ¨ + å·é£ (Curl)
                const time = Date.now() * 0.001;
                // Curl effect: æ—‹è½¬åœº
                const curlFreq = 0.05;
                const curlForce = currentEnv.curl * 0.2;

                // ç®€å•çš„ curl noise æ¨¡æ‹Ÿï¼šdx = sin(y), dy = cos(x)
                const curlX = Math.cos(p.position.y * curlFreq + time) * curlForce;
                const curlY = Math.sin(p.position.x * curlFreq + time) * curlForce;

                // å åŠ  turbulence noise
                const noiseX = Math.sin(p.position.y * 0.1 + time) * currentEnv.turb;
                const noiseY = Math.cos(p.position.x * 0.1 + time) * currentEnv.turb;

                p.position.x += (noiseX + curlX) * 0.1;
                p.position.y += (noiseY + curlY) * 0.1;

                // 3. è§†è§‰æœå‘ä¸æ‹‰ä¼¸
                const vx = currentEnv.h + (noiseX + curlX) * 5;
                const vy = currentEnv.v + (noiseY + curlY) * 5;

                const angle = Math.atan2(vy, vx);
                p.material.rotation = angle;

                const speed = Math.sqrt(vx * vx + vy * vy);
                p.scale.set(2 + speed * 0.2, 0.2 + speed * 0.01, 1);

                // 4. è¾¹ç•Œå¾ªç¯
                const limit = 80;
                if (currentEnv.v > 0) {
                    if (p.position.y > limit) {
                        p.position.y = -limit;
                        p.position.x = (Math.random() - 0.5) * 160;
                    }
                } else {
                    if (p.position.y < -limit) {
                        p.position.y = limit;
                        p.position.x = (Math.random() - 0.5) * 160;
                    }
                }

                if (currentEnv.h > 0) {
                    if (p.position.x > limit) {
                        p.position.x = -limit;
                        p.position.y = (Math.random() - 0.5) * 100;
                    }
                } else if (currentEnv.h < 0) {
                    if (p.position.x < -limit) {
                        p.position.x = limit;
                        p.position.y = (Math.random() - 0.5) * 100;
                    }
                }
            });

            // äº‘çš„å¾®åŠ¨
            cloudParticles.forEach(p => {
                if (p.visible) {
                    p.position.x += Math.sin(Date.now() * 0.001 + p.userData.noise) * currentEnv.turb * 0.1;
                    p.position.y += Math.cos(Date.now() * 0.002 + p.userData.noise) * currentEnv.v * 0.002;
                }
            });

            // æ›´æ–°é£æœº
            if (typeof updatePlane === 'function') {
                updatePlane();
            }

            // æ›´æ–° UI: é«˜åº¦è®¡
            // Map planeY (-20 to 100) to 0-12km (0% to 100%)
            // Let's assume Y=-20 is 0km, Y=100 is 12km. Range = 120.
            const planeH = planeGroup.position.y;
            const pct = Math.max(0, Math.min(100, ((planeH + 20) / 120) * 100));
            const km = ((planeH + 20) / 10).toFixed(1); // 1 unit = 0.1km approx

            document.getElementById('plane-indicator').style.bottom = pct + '%';
            document.getElementById('plane-alt-text').innerText = km + 'km';

            // --- é•œå¤´è·Ÿéšé«˜åº¦ (Camera Follow) ---
            // ç›®æ ‡ç›¸æœºé«˜åº¦ = åŸºç¡€é«˜åº¦ (20) + é£æœºé«˜åº¦ * 0.8
            // é™åˆ¶æœ€ä½é«˜åº¦ï¼Œé˜²æ­¢é’»åœ°
            const targetCamY = Math.max(20, 20 + planeH * 0.8);
            const targetLookY = Math.max(0, planeH * 0.5);

            // å¹³æ»‘æ’å€¼
            camera.position.y += (targetCamY - camera.position.y) * 0.05;
            controls.target.y += (targetLookY - controls.target.y) * 0.05;

            renderer.render(scene, camera);
        }

        // --- 7. é£æœº (The Plane) ---
        const planeGroup = new THREE.Group();
        scene.add(planeGroup);

        function createPlane() {
            // æœºèº«
            const bodyGeo = new THREE.ConeGeometry(0.5, 3, 8);
            bodyGeo.rotateX(Math.PI / 2);
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0xffaa00, flatShading: true });
            const body = new THREE.Mesh(bodyGeo, bodyMat);

            // æœºç¿¼
            const wingGeo = new THREE.BoxGeometry(4, 0.1, 1);
            const wingMat = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true });
            const wing = new THREE.Mesh(wingGeo, wingMat);
            wing.position.set(0, 0, 0.5);
            // å°¾ç¿¼
            const tailGeo = new THREE.BoxGeometry(1.5, 0.1, 0.8);
            const tail = new THREE.Mesh(tailGeo, wingMat);
            tail.position.set(0, 0, -1.2);

            // å‚ç›´å°¾ç¿¼
            const vTailGeo = new THREE.BoxGeometry(0.1, 0.8, 0.8);
            const vTail = new THREE.Mesh(vTailGeo, wingMat);
            vTail.position.set(0, 0.4, -1.2);

            // èºæ—‹æ¡¨ (Propeller)
            const propGeo = new THREE.BoxGeometry(2.2, 0.1, 0.1);
            const propMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const propeller = new THREE.Mesh(propGeo, propMat);
            propeller.position.set(0, 0, 1.6);

            // ç»„åˆ
            const plane = new THREE.Group();
            plane.add(body);
            plane.add(wing);
            plane.add(tail);
            plane.add(vTail);
            plane.add(propeller);

            // ä¿å­˜èºæ—‹æ¡¨å¼•ç”¨ä»¥ä¾¿æ—‹è½¬
            plane.userData = { propeller: propeller };

            return plane;
        }

        const myPlane = createPlane();
        planeGroup.add(myPlane);

        // é£æœºåŠ¨ç”»çŠ¶æ€
        let planeAngle = 0;
        // ç‰©ç†çŠ¶æ€
        let planeY = 10; // ç›®æ ‡å·¡èˆªé«˜åº¦
        let verticalVelocity = 0;

        function updatePlane(dt) {
            // 1. é£è¡Œè·¯å¾„ (å¤§åœ†å‘¨è¿åŠ¨)
            planeAngle += 0.005;
            const r = 40;
            const px = Math.cos(planeAngle) * r;
            const pz = Math.sin(planeAngle) * r;

            // --- ç‰©ç†æ¨¡æ‹Ÿæ ¸å¿ƒ ---
            // å‚ç›´é£åŠ›å½±å“ (Lift from Updraft)
            const liftForce = currentEnv.v * 0.02;

            // è‡ªåŠ¨é©¾é©¶/é‡åŠ›æ¢å¤åŠ› (Restoring Force)
            // é£æœºè¯•å›¾å›åˆ° currentEnv.alt çš„é«˜åº¦
            const targetAltitude = currentEnv.alt;
            const altitudeError = targetAltitude - planeGroup.position.y;
            const restoreForce = altitudeError * 0.01; // å¼¹ç°§ç³»æ•°

            // ç®€å•çš„æ¬§æ‹‰ç§¯åˆ†
            verticalVelocity += liftForce + restoreForce;
            verticalVelocity *= 0.95; // é˜»åŠ›/é˜»å°¼

            // åº”ç”¨ä½ç§»
            planeGroup.position.y += verticalVelocity;

            // é™åˆ¶ä¸€ä¸‹æœ€å¤§é«˜åº¦é˜²æ­¢é£å‡ºå±å¹•å¤ªè¿œ
            if (planeGroup.position.y > 80) planeGroup.position.y = 80;
            if (planeGroup.position.y < -20) planeGroup.position.y = -20;

            // --- å§¿æ€å“åº” (Attitude) ---
            // è®¡ç®—åˆ‡çº¿æ–¹å‘ä½œä¸ºæœå‘
            const targetPos = new THREE.Vector3(px, planeGroup.position.y, pz);
            const lookAtPos = new THREE.Vector3(
                Math.cos(planeAngle + 0.1) * r,
                planeGroup.position.y + verticalVelocity * 5, // ç¨å¾®çœ‹å‘è¿åŠ¨æ–¹å‘
                Math.sin(planeAngle + 0.1) * r
            );

            planeGroup.position.x = px;
            planeGroup.position.z = pz;
            planeGroup.lookAt(lookAtPos);

            // é¢å¤–çš„å§¿æ€æ‰°åŠ¨
            const turb = currentEnv.turb;
            const curl = currentEnv.curl;

            // Pitch (ä¿¯ä»°): 
            // 1. éšå‚ç›´é€Ÿåº¦å€¾æ–œ (çˆ¬å‡æ—¶æŠ¬å¤´)
            // 2. ä¹±æµæ‰°åŠ¨
            const pitchOffset = verticalVelocity * 0.2 + (Math.random() - 0.5) * turb * 0.2;
            myPlane.rotation.x = pitchOffset;

            // Roll (ç¿»æ»š):
            // 1. è½¬å¼¯æ—¶çš„è‡ªç„¶å€¾æ–œ (å‘åœ†å¿ƒå€¾æ–œ)
            // 2. ä¹±æµæ‰°åŠ¨ (ä¸å‡åŒ€å‡åŠ›) + å·é£å½±å“
            const bankAngle = -Math.PI / 8; // åŸºç¡€è½¬å¼¯å€¾è§’
            const rollOffset = (Math.random() - 0.5) * turb * 0.5 + Math.sin(Date.now() * 0.002) * curl * 0.3;
            myPlane.rotation.z = bankAngle + rollOffset;

            // 3. èºæ—‹æ¡¨æ—‹è½¬
            myPlane.userData.propeller.rotation.z += 0.5;
        }





        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>